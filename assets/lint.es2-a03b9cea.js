import{C as q}from"./codemirror.es-f896a2e9.js";import{K as c,G as p,d as D,i as ce,a as S,n as fe,b as w,s as F,c as h,e as R,p as v,f as X,h as y,j as E,D as T,O as G,k as Ue,l as Ve,o as O,q as C,r as I,u as P,v as te,w as je,x as Le,y as de,z as $,A as pe,B as U,C as Me,E as Ye,F as Xe,H as Be,I as qe,J as Ge,L as Je,M as ie,T as me,N as ge,P as Ee,Q as Qe,R as He,S as Ke,U as We,V as ze,W as Ze}from"./index-255a24fc.js";import{R as Te,P as V}from"./Range-52ddcb6a.js";import"./codemirror.es2-ad56cfe0.js";function xe(e){return e.kind===c.OPERATION_DEFINITION||e.kind===c.FRAGMENT_DEFINITION}function en(e){return e.kind===c.SCHEMA_DEFINITION||B(e)||e.kind===c.DIRECTIVE_DEFINITION}function B(e){return e.kind===c.SCALAR_TYPE_DEFINITION||e.kind===c.OBJECT_TYPE_DEFINITION||e.kind===c.INTERFACE_TYPE_DEFINITION||e.kind===c.UNION_TYPE_DEFINITION||e.kind===c.ENUM_TYPE_DEFINITION||e.kind===c.INPUT_OBJECT_TYPE_DEFINITION}function nn(e){return e.kind===c.SCHEMA_EXTENSION||Ne(e)}function Ne(e){return e.kind===c.SCALAR_TYPE_EXTENSION||e.kind===c.OBJECT_TYPE_EXTENSION||e.kind===c.INTERFACE_TYPE_EXTENSION||e.kind===c.UNION_TYPE_EXTENSION||e.kind===c.ENUM_TYPE_EXTENSION||e.kind===c.INPUT_OBJECT_TYPE_EXTENSION}function ve(e){return{Document(t){for(const n of t.definitions)if(!xe(n)){const i=n.kind===c.SCHEMA_DEFINITION||n.kind===c.SCHEMA_EXTENSION?"schema":'"'+n.name.value+'"';e.reportError(new p(`The ${i} definition is not executable.`,{nodes:n}))}return!1}}}function tn(e){return{Field(t){const n=e.getParentType();if(n&&!e.getFieldDef()){const r=e.getSchema(),s=t.name.value;let o=D("to use an inline fragment on",rn(r,n,s));o===""&&(o=D(sn(n,s))),e.reportError(new p(`Cannot query field "${s}" on type "${n.name}".`+o,{nodes:t}))}}}}function rn(e,t,n){if(!ce(t))return[];const i=new Set,r=Object.create(null);for(const o of e.getPossibleTypes(t))if(o.getFields()[n]){i.add(o),r[o.name]=1;for(const a of o.getInterfaces()){var s;a.getFields()[n]&&(i.add(a),r[a.name]=((s=r[a.name])!==null&&s!==void 0?s:0)+1)}}return[...i].sort((o,a)=>{const l=r[a.name]-r[o.name];return l!==0?l:S(o)&&e.isSubType(o,a)?-1:S(a)&&e.isSubType(a,o)?1:fe(o.name,a.name)}).map(o=>o.name)}function sn(e,t){if(w(e)||S(e)){const n=Object.keys(e.getFields());return F(t,n)}return[]}function ye(e){return{InlineFragment(t){const n=t.typeCondition;if(n){const i=h(e.getSchema(),n);if(i&&!R(i)){const r=v(n);e.reportError(new p(`Fragment cannot condition on non composite type "${r}".`,{nodes:n}))}}},FragmentDefinition(t){const n=h(e.getSchema(),t.typeCondition);if(n&&!R(n)){const i=v(t.typeCondition);e.reportError(new p(`Fragment "${t.name.value}" cannot condition on non composite type "${i}".`,{nodes:t.typeCondition}))}}}}function an(e){return{...on(e),Argument(t){const n=e.getArgument(),i=e.getFieldDef(),r=e.getParentType();if(!n&&i&&r){const s=t.name.value,o=i.args.map(l=>l.name),a=F(s,o);e.reportError(new p(`Unknown argument "${s}" on field "${r.name}.${i.name}".`+D(a),{nodes:t}))}}}}function on(e){const t=Object.create(null),n=e.getSchema(),i=n?n.getDirectives():X;for(const o of i)t[o.name]=o.args.map(a=>a.name);const r=e.getDocument().definitions;for(const o of r)if(o.kind===c.DIRECTIVE_DEFINITION){var s;const a=(s=o.arguments)!==null&&s!==void 0?s:[];t[o.name.value]=a.map(l=>l.name.value)}return{Directive(o){const a=o.name.value,l=t[a];if(o.arguments&&l)for(const u of o.arguments){const f=u.name.value;if(!l.includes(f)){const d=F(f,l);e.reportError(new p(`Unknown argument "${f}" on directive "@${a}".`+D(d),{nodes:u}))}}return!1}}}function Ie(e){const t=Object.create(null),n=e.getSchema(),i=n?n.getDirectives():X;for(const s of i)t[s.name]=s.locations;const r=e.getDocument().definitions;for(const s of r)s.kind===c.DIRECTIVE_DEFINITION&&(t[s.name.value]=s.locations.map(o=>o.value));return{Directive(s,o,a,l,u){const f=s.name.value,d=t[f];if(!d){e.reportError(new p(`Unknown directive "@${f}".`,{nodes:s}));return}const m=ln(u);m&&!d.includes(m)&&e.reportError(new p(`Directive "@${f}" may not be used on ${m}.`,{nodes:s}))}}}function ln(e){const t=e[e.length-1];switch("kind"in t||y(!1),t.kind){case c.OPERATION_DEFINITION:return un(t.operation);case c.FIELD:return T.FIELD;case c.FRAGMENT_SPREAD:return T.FRAGMENT_SPREAD;case c.INLINE_FRAGMENT:return T.INLINE_FRAGMENT;case c.FRAGMENT_DEFINITION:return T.FRAGMENT_DEFINITION;case c.VARIABLE_DEFINITION:return T.VARIABLE_DEFINITION;case c.SCHEMA_DEFINITION:case c.SCHEMA_EXTENSION:return T.SCHEMA;case c.SCALAR_TYPE_DEFINITION:case c.SCALAR_TYPE_EXTENSION:return T.SCALAR;case c.OBJECT_TYPE_DEFINITION:case c.OBJECT_TYPE_EXTENSION:return T.OBJECT;case c.FIELD_DEFINITION:return T.FIELD_DEFINITION;case c.INTERFACE_TYPE_DEFINITION:case c.INTERFACE_TYPE_EXTENSION:return T.INTERFACE;case c.UNION_TYPE_DEFINITION:case c.UNION_TYPE_EXTENSION:return T.UNION;case c.ENUM_TYPE_DEFINITION:case c.ENUM_TYPE_EXTENSION:return T.ENUM;case c.ENUM_VALUE_DEFINITION:return T.ENUM_VALUE;case c.INPUT_OBJECT_TYPE_DEFINITION:case c.INPUT_OBJECT_TYPE_EXTENSION:return T.INPUT_OBJECT;case c.INPUT_VALUE_DEFINITION:{const n=e[e.length-3];return"kind"in n||y(!1),n.kind===c.INPUT_OBJECT_TYPE_DEFINITION?T.INPUT_FIELD_DEFINITION:T.ARGUMENT_DEFINITION}default:y(!1,"Unexpected kind: "+E(t.kind))}}function un(e){switch(e){case G.QUERY:return T.QUERY;case G.MUTATION:return T.MUTATION;case G.SUBSCRIPTION:return T.SUBSCRIPTION}}function he(e){return{FragmentSpread(t){const n=t.name.value;e.getFragment(n)||e.reportError(new p(`Unknown fragment "${n}".`,{nodes:t.name}))}}}function Oe(e){const t=e.getSchema(),n=t?t.getTypeMap():Object.create(null),i=Object.create(null);for(const s of e.getDocument().definitions)B(s)&&(i[s.name.value]=!0);const r=[...Object.keys(n),...Object.keys(i)];return{NamedType(s,o,a,l,u){const f=s.name.value;if(!n[f]&&!i[f]){var d;const m=(d=u[2])!==null&&d!==void 0?d:a,g=m!=null&&cn(m);if(g&&re.includes(f))return;const N=F(f,g?re.concat(r):r);e.reportError(new p(`Unknown type "${f}".`+D(N),{nodes:s}))}}}}const re=[...Ue,...Ve].map(e=>e.name);function cn(e){return"kind"in e&&(en(e)||nn(e))}function fn(e){let t=0;return{Document(n){t=n.definitions.filter(i=>i.kind===c.OPERATION_DEFINITION).length},OperationDefinition(n){!n.name&&t>1&&e.reportError(new p("This anonymous operation must be the only defined operation.",{nodes:n}))}}}function dn(e){var t,n,i;const r=e.getSchema(),s=(t=(n=(i=r==null?void 0:r.astNode)!==null&&i!==void 0?i:r==null?void 0:r.getQueryType())!==null&&n!==void 0?n:r==null?void 0:r.getMutationType())!==null&&t!==void 0?t:r==null?void 0:r.getSubscriptionType();let o=0;return{SchemaDefinition(a){if(s){e.reportError(new p("Cannot define a new schema within a schema extension.",{nodes:a}));return}o>0&&e.reportError(new p("Must provide only one schema definition.",{nodes:a})),++o}}}const pn=3;function mn(e){function t(n,i=Object.create(null),r=0){if(n.kind===c.FRAGMENT_SPREAD){const s=n.name.value;if(i[s]===!0)return!1;const o=e.getFragment(s);if(!o)return!1;try{return i[s]=!0,t(o,i,r)}finally{i[s]=void 0}}if(n.kind===c.FIELD&&(n.name.value==="fields"||n.name.value==="interfaces"||n.name.value==="possibleTypes"||n.name.value==="inputFields")&&(r++,r>=pn))return!0;if("selectionSet"in n&&n.selectionSet){for(const s of n.selectionSet.selections)if(t(s,i,r))return!0}return!1}return{Field(n){if((n.name.value==="__schema"||n.name.value==="__type")&&t(n))return e.reportError(new p("Maximum introspection depth exceeded",{nodes:[n]})),!1}}}function gn(e){const t=Object.create(null),n=[],i=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(s){return r(s),!1}};function r(s){if(t[s.name.value])return;const o=s.name.value;t[o]=!0;const a=e.getFragmentSpreads(s.selectionSet);if(a.length!==0){i[o]=n.length;for(const l of a){const u=l.name.value,f=i[u];if(n.push(l),f===void 0){const d=e.getFragment(u);d&&r(d)}else{const d=n.slice(f),m=d.slice(0,-1).map(g=>'"'+g.name.value+'"').join(", ");e.reportError(new p(`Cannot spread fragment "${u}" within itself`+(m!==""?` via ${m}.`:"."),{nodes:d}))}n.pop()}i[o]=void 0}}}function En(e){let t=Object.create(null);return{OperationDefinition:{enter(){t=Object.create(null)},leave(n){const i=e.getRecursiveVariableUsages(n);for(const{node:r}of i){const s=r.name.value;t[s]!==!0&&e.reportError(new p(n.name?`Variable "$${s}" is not defined by operation "${n.name.value}".`:`Variable "$${s}" is not defined.`,{nodes:[r,n]}))}}},VariableDefinition(n){t[n.variable.name.value]=!0}}}function be(e){const t=[],n=[];return{OperationDefinition(i){return t.push(i),!1},FragmentDefinition(i){return n.push(i),!1},Document:{leave(){const i=Object.create(null);for(const r of t)for(const s of e.getRecursivelyReferencedFragments(r))i[s.name.value]=!0;for(const r of n){const s=r.name.value;i[s]!==!0&&e.reportError(new p(`Fragment "${s}" is never used.`,{nodes:r}))}}}}}function Tn(e){let t=[];return{OperationDefinition:{enter(){t=[]},leave(n){const i=Object.create(null),r=e.getRecursiveVariableUsages(n);for(const{node:s}of r)i[s.name.value]=!0;for(const s of t){const o=s.variable.name.value;i[o]!==!0&&e.reportError(new p(n.name?`Variable "$${o}" is never used in operation "${n.name.value}".`:`Variable "$${o}" is never used.`,{nodes:s}))}}},VariableDefinition(n){t.push(n)}}}function z(e){switch(e.kind){case c.OBJECT:return{...e,fields:Nn(e.fields)};case c.LIST:return{...e,values:e.values.map(z)};case c.INT:case c.FLOAT:case c.STRING:case c.BOOLEAN:case c.NULL:case c.ENUM:case c.VARIABLE:return e}}function Nn(e){return e.map(t=>({...t,value:z(t.value)})).sort((t,n)=>fe(t.name.value,n.name.value))}function De(e){return Array.isArray(e)?e.map(([t,n])=>`subfields "${t}" conflict because `+De(n)).join(" and "):e}function vn(e){const t=new Dn,n=new Map;return{SelectionSet(i){const r=yn(e,n,t,e.getParentType(),i);for(const[[s,o],a,l]of r){const u=De(o);e.reportError(new p(`Fields "${s}" conflict because ${u}. Use different aliases on the fields to fetch both if this was intentional.`,{nodes:a.concat(l)}))}}}}function yn(e,t,n,i,r){const s=[],[o,a]=M(e,t,i,r);if(hn(e,s,t,n,o),a.length!==0)for(let l=0;l<a.length;l++){j(e,s,t,n,!1,o,a[l]);for(let u=l+1;u<a.length;u++)L(e,s,t,n,!1,a[l],a[u])}return s}function j(e,t,n,i,r,s,o){const a=e.getFragment(o);if(!a)return;const[l,u]=H(e,n,a);if(s!==l){Z(e,t,n,i,r,s,l);for(const f of u)i.has(f,o,r)||(i.add(f,o,r),j(e,t,n,i,r,s,f))}}function L(e,t,n,i,r,s,o){if(s===o||i.has(s,o,r))return;i.add(s,o,r);const a=e.getFragment(s),l=e.getFragment(o);if(!a||!l)return;const[u,f]=H(e,n,a),[d,m]=H(e,n,l);Z(e,t,n,i,r,u,d);for(const g of m)L(e,t,n,i,r,s,g);for(const g of f)L(e,t,n,i,r,g,o)}function In(e,t,n,i,r,s,o,a){const l=[],[u,f]=M(e,t,r,s),[d,m]=M(e,t,o,a);Z(e,l,t,n,i,u,d);for(const g of m)j(e,l,t,n,i,u,g);for(const g of f)j(e,l,t,n,i,d,g);for(const g of f)for(const N of m)L(e,l,t,n,i,g,N);return l}function hn(e,t,n,i,r){for(const[s,o]of Object.entries(r))if(o.length>1)for(let a=0;a<o.length;a++)for(let l=a+1;l<o.length;l++){const u=_e(e,n,i,!1,s,o[a],o[l]);u&&t.push(u)}}function Z(e,t,n,i,r,s,o){for(const[a,l]of Object.entries(s)){const u=o[a];if(u)for(const f of l)for(const d of u){const m=_e(e,n,i,r,a,f,d);m&&t.push(m)}}}function _e(e,t,n,i,r,s,o){const[a,l,u]=s,[f,d,m]=o,g=i||a!==f&&w(a)&&w(f);if(!g){const A=l.name.value,ne=d.name.value;if(A!==ne)return[[r,`"${A}" and "${ne}" are different fields`],[l],[d]];if(!On(l,d))return[[r,"they have differing arguments"],[l],[d]]}const N=u==null?void 0:u.type,_=m==null?void 0:m.type;if(N&&_&&Q(N,_))return[[r,`they return conflicting types "${E(N)}" and "${E(_)}"`],[l],[d]];const x=l.selectionSet,ee=d.selectionSet;if(x&&ee){const A=In(e,t,n,g,O(N),x,O(_),ee);return bn(A,r,l,d)}}function On(e,t){const n=e.arguments,i=t.arguments;if(n===void 0||n.length===0)return i===void 0||i.length===0;if(i===void 0||i.length===0||n.length!==i.length)return!1;const r=new Map(i.map(({name:s,value:o})=>[s.value,o]));return n.every(s=>{const o=s.value,a=r.get(s.name.value);return a===void 0?!1:se(o)===se(a)})}function se(e){return v(z(e))}function Q(e,t){return C(e)?C(t)?Q(e.ofType,t.ofType):!0:C(t)?!0:I(e)?I(t)?Q(e.ofType,t.ofType):!0:I(t)?!0:P(e)||P(t)?e!==t:!1}function M(e,t,n,i){const r=t.get(i);if(r)return r;const s=Object.create(null),o=Object.create(null);Se(e,n,i,s,o);const a=[s,Object.keys(o)];return t.set(i,a),a}function H(e,t,n){const i=t.get(n.selectionSet);if(i)return i;const r=h(e.getSchema(),n.typeCondition);return M(e,t,r,n.selectionSet)}function Se(e,t,n,i,r){for(const s of n.selections)switch(s.kind){case c.FIELD:{const o=s.name.value;let a;(w(t)||S(t))&&(a=t.getFields()[o]);const l=s.alias?s.alias.value:o;i[l]||(i[l]=[]),i[l].push([t,s,a]);break}case c.FRAGMENT_SPREAD:r[s.name.value]=!0;break;case c.INLINE_FRAGMENT:{const o=s.typeCondition,a=o?h(e.getSchema(),o):t;Se(e,a,s.selectionSet,i,r);break}}}function bn(e,t,n,i){if(e.length>0)return[[t,e.map(([r])=>r)],[n,...e.map(([,r])=>r).flat()],[i,...e.map(([,,r])=>r).flat()]]}class Dn{constructor(){this._data=new Map}has(t,n,i){var r;const[s,o]=t<n?[t,n]:[n,t],a=(r=this._data.get(s))===null||r===void 0?void 0:r.get(o);return a===void 0?!1:i?!0:i===a}add(t,n,i){const[r,s]=t<n?[t,n]:[n,t],o=this._data.get(r);o===void 0?this._data.set(r,new Map([[s,i]])):o.set(s,i)}}function _n(e){return{InlineFragment(t){const n=e.getType(),i=e.getParentType();if(R(n)&&R(i)&&!te(e.getSchema(),n,i)){const r=E(i),s=E(n);e.reportError(new p(`Fragment cannot be spread here as objects of type "${r}" can never be of type "${s}".`,{nodes:t}))}},FragmentSpread(t){const n=t.name.value,i=Sn(e,n),r=e.getParentType();if(i&&r&&!te(e.getSchema(),i,r)){const s=E(r),o=E(i);e.reportError(new p(`Fragment "${n}" cannot be spread here as objects of type "${s}" can never be of type "${o}".`,{nodes:t}))}}}}function Sn(e,t){const n=e.getFragment(t);if(n){const i=h(e.getSchema(),n.typeCondition);if(R(i))return i}}function wn(e){const t=e.getSchema(),n=Object.create(null);for(const r of e.getDocument().definitions)B(r)&&(n[r.name.value]=r);return{ScalarTypeExtension:i,ObjectTypeExtension:i,InterfaceTypeExtension:i,UnionTypeExtension:i,EnumTypeExtension:i,InputObjectTypeExtension:i};function i(r){const s=r.name.value,o=n[s],a=t==null?void 0:t.getType(s);let l;if(o?l=Fn[o.kind]:a&&(l=Rn(a)),l){if(l!==r.kind){const u=$n(r.kind);e.reportError(new p(`Cannot extend non-${u} type "${s}".`,{nodes:o?[o,r]:r}))}}else{const u=Object.keys({...n,...t==null?void 0:t.getTypeMap()}),f=F(s,u);e.reportError(new p(`Cannot extend type "${s}" because it is not defined.`+D(f),{nodes:r.name}))}}}const Fn={[c.SCALAR_TYPE_DEFINITION]:c.SCALAR_TYPE_EXTENSION,[c.OBJECT_TYPE_DEFINITION]:c.OBJECT_TYPE_EXTENSION,[c.INTERFACE_TYPE_DEFINITION]:c.INTERFACE_TYPE_EXTENSION,[c.UNION_TYPE_DEFINITION]:c.UNION_TYPE_EXTENSION,[c.ENUM_TYPE_DEFINITION]:c.ENUM_TYPE_EXTENSION,[c.INPUT_OBJECT_TYPE_DEFINITION]:c.INPUT_OBJECT_TYPE_EXTENSION};function Rn(e){if(je(e))return c.SCALAR_TYPE_EXTENSION;if(w(e))return c.OBJECT_TYPE_EXTENSION;if(S(e))return c.INTERFACE_TYPE_EXTENSION;if(Le(e))return c.UNION_TYPE_EXTENSION;if(de(e))return c.ENUM_TYPE_EXTENSION;if($(e))return c.INPUT_OBJECT_TYPE_EXTENSION;y(!1,"Unexpected type: "+E(e))}function $n(e){switch(e){case c.SCALAR_TYPE_EXTENSION:return"scalar";case c.OBJECT_TYPE_EXTENSION:return"object";case c.INTERFACE_TYPE_EXTENSION:return"interface";case c.UNION_TYPE_EXTENSION:return"union";case c.ENUM_TYPE_EXTENSION:return"enum";case c.INPUT_OBJECT_TYPE_EXTENSION:return"input object";default:y(!1,"Unexpected kind: "+E(e))}}function we(e){return{...An(e),Field:{leave(t){var n;const i=e.getFieldDef();if(!i)return!1;const r=new Set((n=t.arguments)===null||n===void 0?void 0:n.map(s=>s.name.value));for(const s of i.args)if(!r.has(s.name)&&pe(s)){const o=E(s.type);e.reportError(new p(`Field "${i.name}" argument "${s.name}" of type "${o}" is required, but it was not provided.`,{nodes:t}))}}}}}function An(e){var t;const n=Object.create(null),i=e.getSchema(),r=(t=i==null?void 0:i.getDirectives())!==null&&t!==void 0?t:X;for(const a of r)n[a.name]=U(a.args.filter(pe),l=>l.name);const s=e.getDocument().definitions;for(const a of s)if(a.kind===c.DIRECTIVE_DEFINITION){var o;const l=(o=a.arguments)!==null&&o!==void 0?o:[];n[a.name.value]=U(l.filter(kn),u=>u.name.value)}return{Directive:{leave(a){const l=a.name.value,u=n[l];if(u){var f;const d=(f=a.arguments)!==null&&f!==void 0?f:[],m=new Set(d.map(g=>g.name.value));for(const[g,N]of Object.entries(u))if(!m.has(g)){const _=Me(N.type)?E(N.type):v(N.type);e.reportError(new p(`Directive "@${l}" argument "${g}" of type "${_}" is required, but it was not provided.`,{nodes:a}))}}}}}}function kn(e){return e.type.kind===c.NON_NULL_TYPE&&e.defaultValue==null}function Cn(e){return{Field(t){const n=e.getType(),i=t.selectionSet;if(n){if(P(O(n))){if(i){const r=t.name.value,s=E(n);e.reportError(new p(`Field "${r}" must not have a selection since type "${s}" has no subfields.`,{nodes:i}))}}else if(!i){const r=t.name.value,s=E(n);e.reportError(new p(`Field "${r}" of type "${s}" must have a selection of subfields. Did you mean "${r} { ... }"?`,{nodes:t}))}}}}}function Pn(e,t,n){var i;const r={},s=(i=t.arguments)!==null&&i!==void 0?i:[],o=U(s,a=>a.name.value);for(const a of e.args){const l=a.name,u=a.type,f=o[l];if(!f){if(a.defaultValue!==void 0)r[l]=a.defaultValue;else if(I(u))throw new p(`Argument "${l}" of required type "${E(u)}" was not provided.`,{nodes:t});continue}const d=f.value;let m=d.kind===c.NULL;if(d.kind===c.VARIABLE){const N=d.name.value;if(n==null||!Un(n,N)){if(a.defaultValue!==void 0)r[l]=a.defaultValue;else if(I(u))throw new p(`Argument "${l}" of required type "${E(u)}" was provided the variable "$${N}" which was not provided a runtime value.`,{nodes:d});continue}m=n[N]==null}if(m&&I(u))throw new p(`Argument "${l}" of non-null type "${E(u)}" must not be null.`,{nodes:d});const g=Ye(d,u,n);if(g===void 0)throw new p(`Argument "${l}" has invalid value ${v(d)}.`,{nodes:d});r[l]=g}return r}function ae(e,t,n){var i;const r=(i=t.directives)===null||i===void 0?void 0:i.find(s=>s.name.value===e.name);if(r)return Pn(e,r,n)}function Un(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function Vn(e,t,n,i,r){const s=new Map;return K(e,t,n,i,r,s,new Set),s}function K(e,t,n,i,r,s,o){for(const a of r.selections)switch(a.kind){case c.FIELD:{if(!J(n,a))continue;const l=jn(a),u=s.get(l);u!==void 0?u.push(a):s.set(l,[a]);break}case c.INLINE_FRAGMENT:{if(!J(n,a)||!oe(e,a,i))continue;K(e,t,n,i,a.selectionSet,s,o);break}case c.FRAGMENT_SPREAD:{const l=a.name.value;if(o.has(l)||!J(n,a))continue;o.add(l);const u=t[l];if(!u||!oe(e,u,i))continue;K(e,t,n,i,u.selectionSet,s,o);break}}}function J(e,t){const n=ae(Xe,t,e);if((n==null?void 0:n.if)===!0)return!1;const i=ae(Be,t,e);return(i==null?void 0:i.if)!==!1}function oe(e,t,n){const i=t.typeCondition;if(!i)return!0;const r=h(e,i);return r===n?!0:ce(r)?e.isSubType(r,n):!1}function jn(e){return e.alias?e.alias.value:e.name.value}function Ln(e){return{OperationDefinition(t){if(t.operation==="subscription"){const n=e.getSchema(),i=n.getSubscriptionType();if(i){const r=t.name?t.name.value:null,s=Object.create(null),o=e.getDocument(),a=Object.create(null);for(const u of o.definitions)u.kind===c.FRAGMENT_DEFINITION&&(a[u.name.value]=u);const l=Vn(n,a,s,i,t.selectionSet);if(l.size>1){const d=[...l.values()].slice(1).flat();e.reportError(new p(r!=null?`Subscription "${r}" must select only one top level field.`:"Anonymous Subscription must select only one top level field.",{nodes:d}))}for(const u of l.values())u[0].name.value.startsWith("__")&&e.reportError(new p(r!=null?`Subscription "${r}" must not select an introspection top level field.`:"Anonymous Subscription must not select an introspection top level field.",{nodes:u}))}}}}}function Fe(e,t){const n=new Map;for(const i of e){const r=t(i),s=n.get(r);s===void 0?n.set(r,[i]):s.push(i)}return n}function Re(e){return{Field:t,Directive:t};function t(n){var i;const r=(i=n.arguments)!==null&&i!==void 0?i:[],s=Fe(r,o=>o.name.value);for(const[o,a]of s)a.length>1&&e.reportError(new p(`There can be only one argument named "${o}".`,{nodes:a.map(l=>l.name)}))}}function Mn(e){const t=Object.create(null),n=e.getSchema();return{DirectiveDefinition(i){const r=i.name.value;if(n!=null&&n.getDirective(r)){e.reportError(new p(`Directive "@${r}" already exists in the schema. It cannot be redefined.`,{nodes:i.name}));return}return t[r]?e.reportError(new p(`There can be only one directive named "@${r}".`,{nodes:[t[r],i.name]})):t[r]=i.name,!1}}}function $e(e){const t=Object.create(null),n=e.getSchema(),i=n?n.getDirectives():X;for(const a of i)t[a.name]=!a.isRepeatable;const r=e.getDocument().definitions;for(const a of r)a.kind===c.DIRECTIVE_DEFINITION&&(t[a.name.value]=!a.repeatable);const s=Object.create(null),o=Object.create(null);return{enter(a){if(!("directives"in a)||!a.directives)return;let l;if(a.kind===c.SCHEMA_DEFINITION||a.kind===c.SCHEMA_EXTENSION)l=s;else if(B(a)||Ne(a)){const u=a.name.value;l=o[u],l===void 0&&(o[u]=l=Object.create(null))}else l=Object.create(null);for(const u of a.directives){const f=u.name.value;t[f]&&(l[f]?e.reportError(new p(`The directive "@${f}" can only be used once at this location.`,{nodes:[l[f],u]})):l[f]=u)}}}}function Yn(e){const t=e.getSchema(),n=t?t.getTypeMap():Object.create(null),i=Object.create(null);return{EnumTypeDefinition:r,EnumTypeExtension:r};function r(s){var o;const a=s.name.value;i[a]||(i[a]=Object.create(null));const l=(o=s.values)!==null&&o!==void 0?o:[],u=i[a];for(const f of l){const d=f.name.value,m=n[a];de(m)&&m.getValue(d)?e.reportError(new p(`Enum value "${a}.${d}" already exists in the schema. It cannot also be defined in this type extension.`,{nodes:f.name})):u[d]?e.reportError(new p(`Enum value "${a}.${d}" can only be defined once.`,{nodes:[u[d],f.name]})):u[d]=f.name}return!1}}function Xn(e){const t=e.getSchema(),n=t?t.getTypeMap():Object.create(null),i=Object.create(null);return{InputObjectTypeDefinition:r,InputObjectTypeExtension:r,InterfaceTypeDefinition:r,InterfaceTypeExtension:r,ObjectTypeDefinition:r,ObjectTypeExtension:r};function r(s){var o;const a=s.name.value;i[a]||(i[a]=Object.create(null));const l=(o=s.fields)!==null&&o!==void 0?o:[],u=i[a];for(const f of l){const d=f.name.value;Bn(n[a],d)?e.reportError(new p(`Field "${a}.${d}" already exists in the schema. It cannot also be defined in this type extension.`,{nodes:f.name})):u[d]?e.reportError(new p(`Field "${a}.${d}" can only be defined once.`,{nodes:[u[d],f.name]})):u[d]=f.name}return!1}}function Bn(e,t){return w(e)||S(e)||$(e)?e.getFields()[t]!=null:!1}function qn(e){const t=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(n){const i=n.name.value;return t[i]?e.reportError(new p(`There can be only one fragment named "${i}".`,{nodes:[t[i],n.name]})):t[i]=n.name,!1}}}function Ae(e){const t=[];let n=Object.create(null);return{ObjectValue:{enter(){t.push(n),n=Object.create(null)},leave(){const i=t.pop();i||y(!1),n=i}},ObjectField(i){const r=i.name.value;n[r]?e.reportError(new p(`There can be only one input field named "${r}".`,{nodes:[n[r],i.name]})):n[r]=i.name}}}function Gn(e){const t=Object.create(null);return{OperationDefinition(n){const i=n.name;return i&&(t[i.value]?e.reportError(new p(`There can be only one operation named "${i.value}".`,{nodes:[t[i.value],i]})):t[i.value]=i),!1},FragmentDefinition:()=>!1}}function Jn(e){const t=e.getSchema(),n=Object.create(null),i=t?{query:t.getQueryType(),mutation:t.getMutationType(),subscription:t.getSubscriptionType()}:{};return{SchemaDefinition:r,SchemaExtension:r};function r(s){var o;const a=(o=s.operationTypes)!==null&&o!==void 0?o:[];for(const l of a){const u=l.operation,f=n[u];i[u]?e.reportError(new p(`Type for ${u} already defined in the schema. It cannot be redefined.`,{nodes:l})):f?e.reportError(new p(`There can be only one ${u} type in schema.`,{nodes:[f,l]})):n[u]=l}return!1}}function Qn(e){const t=Object.create(null),n=e.getSchema();return{ScalarTypeDefinition:i,ObjectTypeDefinition:i,InterfaceTypeDefinition:i,UnionTypeDefinition:i,EnumTypeDefinition:i,InputObjectTypeDefinition:i};function i(r){const s=r.name.value;if(n!=null&&n.getType(s)){e.reportError(new p(`Type "${s}" already exists in the schema. It cannot also be defined in this type definition.`,{nodes:r.name}));return}return t[s]?e.reportError(new p(`There can be only one type named "${s}".`,{nodes:[t[s],r.name]})):t[s]=r.name,!1}}function ke(e){return{OperationDefinition(t){var n;const i=(n=t.variableDefinitions)!==null&&n!==void 0?n:[],r=Fe(i,s=>s.variable.name.value);for(const[s,o]of r)o.length>1&&e.reportError(new p(`There can be only one variable named "$${s}".`,{nodes:o.map(a=>a.variable.name)}))}}}function Hn(e){let t={};return{OperationDefinition:{enter(){t={}}},VariableDefinition(n){t[n.variable.name.value]=n},ListValue(n){const i=qe(e.getParentInputType());if(!C(i))return b(e,n),!1},ObjectValue(n){const i=O(e.getInputType());if(!$(i))return b(e,n),!1;const r=U(n.fields,s=>s.name.value);for(const s of Object.values(i.getFields()))if(!r[s.name]&&Ge(s)){const a=E(s.type);e.reportError(new p(`Field "${i.name}.${s.name}" of required type "${a}" was not provided.`,{nodes:n}))}i.isOneOf&&Kn(e,n,i,r,t)},ObjectField(n){const i=O(e.getParentInputType());if(!e.getInputType()&&$(i)){const s=F(n.name.value,Object.keys(i.getFields()));e.reportError(new p(`Field "${n.name.value}" is not defined by type "${i.name}".`+D(s),{nodes:n}))}},NullValue(n){const i=e.getInputType();I(i)&&e.reportError(new p(`Expected value of type "${E(i)}", found ${v(n)}.`,{nodes:n}))},EnumValue:n=>b(e,n),IntValue:n=>b(e,n),FloatValue:n=>b(e,n),StringValue:n=>b(e,n),BooleanValue:n=>b(e,n)}}function b(e,t){const n=e.getInputType();if(!n)return;const i=O(n);if(!P(i)){const r=E(n);e.reportError(new p(`Expected value of type "${r}", found ${v(t)}.`,{nodes:t}));return}try{if(i.parseLiteral(t,void 0)===void 0){const s=E(n);e.reportError(new p(`Expected value of type "${s}", found ${v(t)}.`,{nodes:t}))}}catch(r){const s=E(n);r instanceof p?e.reportError(r):e.reportError(new p(`Expected value of type "${s}", found ${v(t)}; `+r.message,{nodes:t,originalError:r}))}}function Kn(e,t,n,i,r){var s;const o=Object.keys(i);if(o.length!==1){e.reportError(new p(`OneOf Input Object "${n.name}" must specify exactly one key.`,{nodes:[t]}));return}const l=(s=i[o[0]])===null||s===void 0?void 0:s.value,u=!l||l.kind===c.NULL,f=(l==null?void 0:l.kind)===c.VARIABLE;if(u){e.reportError(new p(`Field "${n.name}.${o[0]}" must be non-null.`,{nodes:[t]}));return}if(f){const d=l.name.value;r[d].type.kind!==c.NON_NULL_TYPE&&e.reportError(new p(`Variable "${d}" must be non-nullable to be used for OneOf Input Object "${n.name}".`,{nodes:[t]}))}}function Wn(e){return{VariableDefinition(t){const n=h(e.getSchema(),t.type);if(n!==void 0&&!Je(n)){const i=t.variable.name.value,r=v(t.type);e.reportError(new p(`Variable "$${i}" cannot be non-input type "${r}".`,{nodes:t.type}))}}}}function zn(e){let t=Object.create(null);return{OperationDefinition:{enter(){t=Object.create(null)},leave(n){const i=e.getRecursiveVariableUsages(n);for(const{node:r,type:s,defaultValue:o}of i){const a=r.name.value,l=t[a];if(l&&s){const u=e.getSchema(),f=h(u,l.type);if(f&&!Zn(u,f,l.defaultValue,s,o)){const d=E(f),m=E(s);e.reportError(new p(`Variable "$${a}" of type "${d}" used in position expecting type "${m}".`,{nodes:[l,r]}))}}}}},VariableDefinition(n){t[n.variable.name.value]=n}}}function Zn(e,t,n,i,r){if(I(i)&&!I(t)){if(!(n!=null&&n.kind!==c.NULL)&&!(r!==void 0))return!1;const a=i.ofType;return ie(e,t,a)}return ie(e,t,i)}const xn=Object.freeze([mn]),Ce=Object.freeze([ve,Gn,fn,Ln,Oe,ye,Wn,Cn,tn,qn,he,be,_n,gn,ke,En,Tn,Ie,$e,an,Re,Hn,we,zn,vn,Ae,...xn]);class et{constructor(t,n){this._ast=t,this._fragments=void 0,this._fragmentSpreads=new Map,this._recursivelyReferencedFragments=new Map,this._onError=n}get[Symbol.toStringTag](){return"ASTValidationContext"}reportError(t){this._onError(t)}getDocument(){return this._ast}getFragment(t){let n;if(this._fragments)n=this._fragments;else{n=Object.create(null);for(const i of this.getDocument().definitions)i.kind===c.FRAGMENT_DEFINITION&&(n[i.name.value]=i);this._fragments=n}return n[t]}getFragmentSpreads(t){let n=this._fragmentSpreads.get(t);if(!n){n=[];const i=[t];let r;for(;r=i.pop();)for(const s of r.selections)s.kind===c.FRAGMENT_SPREAD?n.push(s):s.selectionSet&&i.push(s.selectionSet);this._fragmentSpreads.set(t,n)}return n}getRecursivelyReferencedFragments(t){let n=this._recursivelyReferencedFragments.get(t);if(!n){n=[];const i=Object.create(null),r=[t.selectionSet];let s;for(;s=r.pop();)for(const o of this.getFragmentSpreads(s)){const a=o.name.value;if(i[a]!==!0){i[a]=!0;const l=this.getFragment(a);l&&(n.push(l),r.push(l.selectionSet))}}this._recursivelyReferencedFragments.set(t,n)}return n}}class nt extends et{constructor(t,n,i,r){super(n,r),this._schema=t,this._typeInfo=i,this._variableUsages=new Map,this._recursiveVariableUsages=new Map}get[Symbol.toStringTag](){return"ValidationContext"}getSchema(){return this._schema}getVariableUsages(t){let n=this._variableUsages.get(t);if(!n){const i=[],r=new me(this._schema);ge(t,Ee(r,{VariableDefinition:()=>!1,Variable(s){i.push({node:s,type:r.getInputType(),defaultValue:r.getDefaultValue()})}})),n=i,this._variableUsages.set(t,n)}return n}getRecursiveVariableUsages(t){let n=this._recursiveVariableUsages.get(t);if(!n){n=this.getVariableUsages(t);for(const i of this.getRecursivelyReferencedFragments(t))n=n.concat(this.getVariableUsages(i));this._recursiveVariableUsages.set(t,n)}return n}getType(){return this._typeInfo.getType()}getParentType(){return this._typeInfo.getParentType()}getInputType(){return this._typeInfo.getInputType()}getParentInputType(){return this._typeInfo.getParentInputType()}getFieldDef(){return this._typeInfo.getFieldDef()}getDirective(){return this._typeInfo.getDirective()}getArgument(){return this._typeInfo.getArgument()}getEnumValue(){return this._typeInfo.getEnumValue()}}function Pe(e,t,n=Ce,i,r=new me(e)){var s;const o=(s=i==null?void 0:i.maxErrors)!==null&&s!==void 0?s:100;t||Qe(!1,"Must provide document."),He(e);const a=Object.freeze({}),l=[],u=new nt(e,t,r,d=>{if(l.length>=o)throw l.push(new p("Too many validation errors, error limit reached. Validation aborted.")),a;l.push(d)}),f=Ke(n.map(d=>d(u)));try{ge(t,Ee(r,f))}catch(d){if(d!==a)throw d}return l}function tt(e){return{Field(t){const n=e.getFieldDef(),i=n==null?void 0:n.deprecationReason;if(n&&i!=null){const r=e.getParentType();r!=null||y(!1),e.reportError(new p(`The field ${r.name}.${n.name} is deprecated. ${i}`,{nodes:t}))}},Argument(t){const n=e.getArgument(),i=n==null?void 0:n.deprecationReason;if(n&&i!=null){const r=e.getDirective();if(r!=null)e.reportError(new p(`Directive "@${r.name}" argument "${n.name}" is deprecated. ${i}`,{nodes:t}));else{const s=e.getParentType(),o=e.getFieldDef();s!=null&&o!=null||y(!1),e.reportError(new p(`Field "${s.name}.${o.name}" argument "${n.name}" is deprecated. ${i}`,{nodes:t}))}}},ObjectField(t){const n=O(e.getParentInputType());if($(n)){const i=n.getFields()[t.name.value],r=i==null?void 0:i.deprecationReason;r!=null&&e.reportError(new p(`The input field ${n.name}.${i.name} is deprecated. ${r}`,{nodes:t}))}},EnumValue(t){const n=e.getEnumValue(),i=n==null?void 0:n.deprecationReason;if(n&&i!=null){const r=O(e.getInputType());r!=null||y(!1),e.reportError(new p(`The enum value "${r.name}.${n.name}" is deprecated. ${i}`,{nodes:t}))}}}}const it=[dn,Jn,Qn,Yn,Xn,Mn,Oe,Ie,$e,wn,Re,Ae,ke,ye,we];function rt(e,t,n,i,r){const s=Ce.filter(a=>!(a===be||a===ve||i&&a===he));return n&&Array.prototype.push.apply(s,n),r&&Array.prototype.push.apply(s,it),Pe(e,t,s).filter(a=>{if(a.message.includes("Unknown directive")&&a.nodes){const l=a.nodes[0];if(l&&l.kind===c.DIRECTIVE){const u=l.name.value;if(u==="arguments"||u==="argumentDefinitions")return!1}}return!0})}const k={Error:"Error",Warning:"Warning",Information:"Information",Hint:"Hint"},W={[k.Error]:1,[k.Warning]:2,[k.Information]:3,[k.Hint]:4},Y=(e,t)=>{if(!e)throw new Error(t)};function st(e,t=null,n,i,r){var s,o;let a=null,l="";r&&(l=typeof r=="string"?r:r.reduce((f,d)=>f+v(d)+`

`,""));const u=l?`${e}

${l}`:e;try{a=We(u)}catch(f){if(f instanceof p){const d=ot((o=(s=f.locations)===null||s===void 0?void 0:s[0])!==null&&o!==void 0?o:{line:0,column:0},u);return[{severity:W.Error,message:f.message,source:"GraphQL: Syntax",range:d}]}throw f}return at(a,t,n,i)}function at(e,t=null,n,i){if(!t)return[];const r=rt(t,e,n,i).flatMap(o=>le(o,W.Error,"Validation")),s=Pe(t,e,[tt]).flatMap(o=>le(o,W.Warning,"Deprecation"));return r.concat(s)}function le(e,t,n){if(!e.nodes)return[];const i=[];for(const[r,s]of e.nodes.entries()){const o=s.kind!=="Variable"&&"name"in s&&s.name!==void 0?s.name:"variable"in s&&s.variable!==void 0?s.variable:s;if(o){Y(e.locations,"GraphQL validation error requires locations.");const a=e.locations[r],l=lt(o),u=a.column+(l.end-l.start);i.push({source:`GraphQL: ${n}`,message:e.message,severity:t,range:new Te(new V(a.line-1,a.column-1),new V(a.line-1,u))})}}return i}function ot(e,t){const n=Ze(),i=n.startState(),r=t.split(`
`);Y(r.length>=e.line,"Query text must have more lines than where the error happened");let s=null;for(let u=0;u<e.line;u++)for(s=new ze(r[u]);!s.eol()&&n.token(s,i)!=="invalidchar";);Y(s,"Expected Parser stream to be available.");const o=e.line-1,a=s.getStartOfToken(),l=s.getCurrentPosition();return new Te(new V(o,a),new V(o,l))}function lt(e){const n=e.loc;return Y(n,"Expected ASTNode to have a location."),n}const ue=["error","warning","information","hint"],ut={"GraphQL: Validation":"validation","GraphQL: Deprecation":"deprecation","GraphQL: Syntax":"syntax"};q.registerHelper("lint","graphql",(e,t)=>{const{schema:n,validationRules:i,externalFragments:r}=t;return st(e,n,i,void 0,r).map(a=>({message:a.message,severity:a.severity?ue[a.severity-1]:ue[0],type:a.source?ut[a.source]:void 0,from:q.Pos(a.range.start.line,a.range.start.character),to:q.Pos(a.range.end.line,a.range.end.character)}))});
